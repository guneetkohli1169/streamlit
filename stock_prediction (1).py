# -*- coding: utf-8 -*-
"""stock prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vEm_iCecaFiak3ntmLKbGtlaEXLiu-3E

EXTRACTING STOCK DATA
"""

import yfinance as yf
import pandas as pd

ticker = "RELIANCE.NS"  # or any single stock
data = yf.download(ticker, start="2015-01-01", end="2024-12-31")  # Date, Open, High, Low, Close, Volume
data.dropna(inplace=True)
print(data.head())

"""Creating Bullish / Bearish labels (next day)

We’ll label day t using (Close_{t+1} − Close_t):
"""

df = data.copy()
df["Next_Close"] = df[('Close', ticker)].shift(-1)
df.dropna(inplace=True)

df["Label"] = (df["Next_Close"] > df[('Close', ticker)]).astype(int)  # 1 = Bullish, 0 = Bearish
df.head()

"""Convert price data to candlestick images

We’ll generate sliding windows of, say, 30 candles → one image → one label (of the last day in that window).

Using mplfinance to generate candlesticks
"""

import os
import mplfinance as mpf
from tqdm import tqdm

WINDOW = 30  # number of candles in each image

base_dir = "candles_dataset"
bull_dir = os.path.join(base_dir, "bullish")
bear_dir = os.path.join(base_dir, "bearish")
os.makedirs(bull_dir, exist_ok=True)
os.makedirs(bear_dir, exist_ok=True)

def save_candle_image(chunk, label, idx):
    # chunk is a small OHLC dataframe with Date index
    save_path = os.path.join(bull_dir if label == 1 else bear_dir,
                             f"candle_{idx}.png")

    mpf.plot(
        chunk,
        type='candle',
        style='charles',      # keep same style for all images
        volume=False,
        axisoff=True,
        savefig=dict(fname=save_path, dpi=100, bbox_inches="tight", pad_inches=0.05)
    )

# Create images with sliding window
# Select the OHLC columns from df and flatten their names for mplfinance
ohlc_cols_multiindex = [('Open', ticker), ('High', ticker), ('Low', ticker), ('Close', ticker)]
df_ohlc = df[ohlc_cols_multiindex].copy()
df_ohlc.columns = [col[0] for col in df_ohlc.columns] # Flatten MultiIndex to single level names

for i in tqdm(range(WINDOW, len(df))):
    window_data = df_ohlc.iloc[i-WINDOW:i]
    label = df["Label"].iloc[i-1]  # label based on last day in window
    save_candle_image(window_data, label, i)

"""Build the CNN model (Keras)"""

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator

IMG_SIZE = (128, 128)
BATCH_SIZE = 32

train_datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2
)

train_gen = train_datagen.flow_from_directory(
    "candles_dataset",
    target_size=IMG_SIZE,
    batch_size=BATCH_SIZE,
    class_mode="binary",
    subset="training"
)

val_gen = train_datagen.flow_from_directory(
    "candles_dataset",
    target_size=IMG_SIZE,
    batch_size=BATCH_SIZE,
    class_mode="binary",
    subset="validation"
)

print(train_gen.class_indices)  # e.g. {'bearish': 0, 'bullish': 1}

"""CNN architecture"""

from tensorflow.keras import layers, models

def build_cnn(input_shape=(128, 128, 3)):
    model = models.Sequential([
        layers.Conv2D(32, (3,3), activation="relu", input_shape=input_shape),
        layers.MaxPooling2D((2,2)),

        layers.Conv2D(64, (3,3), activation="relu"),
        layers.MaxPooling2D((2,2)),

        layers.Conv2D(128, (3,3), activation="relu"),
        layers.MaxPooling2D((2,2)),

        layers.Flatten(),
        layers.Dense(128, activation="relu"),
        layers.Dropout(0.5),
        layers.Dense(1, activation="sigmoid")  # binary output
    ])
    model.compile(
        optimizer="adam",
        loss="binary_crossentropy",
        metrics=["accuracy"]
    )
    return model

model = build_cnn()
model.summary()

"""Train and Save"""

EPOCHS = 15

history = model.fit(
    train_gen,
    epochs=EPOCHS,
    validation_data=val_gen
)

model.save("candle_cnn.h5")

from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt

MODEL_PATH = "/content/candle_cnn.h5"  # update if path is different
IMG_PATH = "/content/candles_dataset/sample.png"  # path of uploaded image
IMG_SIZE = (128, 128)  # same size used in training

# Load model
model = load_model(MODEL_PATH)

# Load and preprocess image
img = image.load_img(IMG_PATH, target_size=IMG_SIZE)
img_array = image.img_to_array(img) / 255.0
img_array = np.expand_dims(img_array, axis=0)

# Predict
prob = model.predict(img_array)[0][0]
label = "Bullish" if prob >= 0.5 else "Bearish"

# Show results
plt.imshow(image.load_img(IMG_PATH))
plt.axis('off')
print(f"\nPrediction: {label}")
print(f"Confidence: {prob:.4f}")

from google.colab import files
files.download("/content/candle_cnn.h5")

from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt

MODEL_PATH = "/content/candle_cnn.h5"  # update if path is different
IMG_PATH = "/content/sample 2.png"  # path of uploaded image
IMG_SIZE = (128, 128)  # same size used in training

# Load model
model = load_model(MODEL_PATH)

# Load and preprocess image
img = image.load_img(IMG_PATH, target_size=IMG_SIZE)
img_array = image.img_to_array(img) / 255.0
img_array = np.expand_dims(img_array, axis=0)

# Predict
prob = model.predict(img_array)[0][0]
label = "Bullish" if prob >= 0.5 else "Bearish"

# Show results
plt.imshow(image.load_img(IMG_PATH))
plt.axis('off')
print(f"\nPrediction: {label}")
print(f"Confidence: {prob:.4f}")

import os

bull = len(os.listdir("candles_dataset/bullish"))
bear = len(os.listdir("candles_dataset/bearish"))

print("Bullish:", bull)
print("Bearish:", bear)

from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt

MODEL_PATH = "/content/candle_cnn.h5"  # update if path is different
IMG_PATH = "/content/samples.jpg"  # path of uploaded image
IMG_SIZE = (128, 128)  # same size used in training

# Load model
model = load_model(MODEL_PATH)

# Load and preprocess image
img = image.load_img(IMG_PATH, target_size=IMG_SIZE)
img_array = image.img_to_array(img) / 255.0
img_array = np.expand_dims(img_array, axis=0)

# Predict
prob = model.predict(img_array)[0][0]
label = "Bullish" if prob >= 0.5 else "Bearish"

# Show results
plt.imshow(image.load_img(IMG_PATH))
plt.axis('off')
print(f"\nPrediction: {label}")
print(f"Confidence: {prob:.4f}")

print(train_gen.class_indices)

import glob, os
from tensorflow.keras.preprocessing import image
import numpy as np
import tensorflow as tf

IMG_SIZE = (128,128)
model = tf.keras.models.load_model("candle_cnn.h5")

def quick_predict(path):
    img = image.load_img(path, target_size=IMG_SIZE)
    x = image.img_to_array(img)/255.0
    x = np.expand_dims(x,0)
    prob = model.predict(x)[0][0]
    return "Bullish" if prob>=0.5 else "Bearish"

print("Testing 10 from Bullish folder:")
bull_imgs = glob.glob("candles_dataset/bullish/*")[:10]
for p in bull_imgs:
    print(os.path.basename(p), quick_predict(p))

print("\nTesting 10 from Bearish folder:")
bear_imgs = glob.glob("candles_dataset/bearish/*")[:10]
for p in bear_imgs:
    print(os.path.basename(p), quick_predict(p))

"""# MODEL IS BIASED TOWARDS BULLISH, WE WILL RETRAIN"""

from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras import layers, models
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint

IMG_SIZE = (128, 128)
BATCH_SIZE = 32

train_datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2,
    rotation_range=5,
    width_shift_range=0.05,
    height_shift_range=0.05,
    zoom_range=0.1
)

train_gen = train_datagen.flow_from_directory(
    "candles_dataset",
    target_size=IMG_SIZE,
    batch_size=BATCH_SIZE,
    class_mode="binary",
    subset="training"
)

val_gen = train_datagen.flow_from_directory(
    "candles_dataset",
    target_size=IMG_SIZE,
    batch_size=BATCH_SIZE,
    class_mode="binary",
    subset="validation"
)

def build_better_cnn():
    model = models.Sequential([
        layers.Conv2D(32, 3, activation="relu", input_shape=(128,128,3)),
        layers.BatchNormalization(),
        layers.MaxPooling2D(2),

        layers.Conv2D(64, 3, activation="relu"),
        layers.BatchNormalization(),
        layers.MaxPooling2D(2),

        layers.Conv2D(128, 3, activation="relu"),
        layers.BatchNormalization(),
        layers.MaxPooling2D(2),

        layers.Flatten(),
        layers.Dense(256, activation="relu"),
        layers.Dropout(0.5),
        layers.Dense(1, activation="sigmoid")
    ])
    model.compile(optimizer="adam", loss="binary_crossentropy", metrics=["accuracy"])
    return model

model = build_better_cnn()

callbacks = [
    EarlyStopping(patience=5, restore_best_weights=True, monitor="val_loss"),
    ModelCheckpoint("best_candle_cnn.h5", save_best_only=True, monitor="val_loss")
]

history = model.fit(
    train_gen,
    epochs=30,
    validation_data=val_gen,
    callbacks=callbacks
)

import tensorflow as tf
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
from google.colab import files
import os

MODEL_PATH = "/content/best_candle_cnn.h5"  # ensure this path is correct
IMG_SIZE = (128, 128)
THRESHOLD = 0.55  # tuned threshold (important!)

# Load trained model
model = tf.keras.models.load_model(MODEL_PATH)
print("Model Loaded Successfully ✔")

def predict_candle_image(img_path):
    img = Image.open(img_path).convert("RGB")
    img_resized = img.resize(IMG_SIZE)

    x = np.array(img_resized) / 255.0
    x = np.expand_dims(x, axis=0)

    prob = model.predict(x)[0][0]
    label = "Bullish" if prob >= THRESHOLD else "Bearish"

    plt.imshow(img)
    plt.axis('off')
    plt.title(f"{label} (prob={prob:.3f})")
    plt.show()

    print(f"File: {img_path}")
    print(f"Prediction: {label}")
    print(f"Probability: {prob:.4f} | Threshold: {THRESHOLD}")

print("Upload one or more candlestick images:")
uploaded = files.upload()

for filename in uploaded.keys():
    print(f"\nProcessing: {filename}")
    predict_candle_image(filename)

print("Upload one or more candlestick images:")
uploaded = files.upload()

for filename in uploaded.keys():
    print(f"\nProcessing: {filename}")
    predict_candle_image(filename)

print("Upload one or more candlestick images:")
uploaded = files.upload()

for filename in uploaded.keys():
    print(f"\nProcessing: {filename}")
    predict_candle_image(filename)

print("Upload one or more candlestick images:")
uploaded = files.upload()

for filename in uploaded.keys():
    print(f"\nProcessing: {filename}")
    predict_candle_image(filename)

"""# testing directly from dataset folders"""

import glob

test_samples = glob.glob("candles_dataset/bullish/*.png")[:5] + \
               glob.glob("candles_dataset/bearish/*.png")[:5]

for p in test_samples:
    print(f"\nTesting {os.path.basename(p)}:")
    predict_candle_image(p)

